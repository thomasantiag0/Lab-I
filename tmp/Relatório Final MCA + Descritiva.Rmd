---
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.align="center")
```

```{r, echo=FALSE, include=FALSE}
# Carregando os pacotes necessários
library(ggplot2)
library(tidyverse)
library(epiDisplay)

# Importação do banco de dados e transormação em uma variável da classe data.frame
db = read.csv("../data_HL_children_21-Jan-22.csv")
db <- data.frame(db)

# Seleção das variáveis que compõem os blocos
db_blocos <- db %>% 
  dplyr::select(
    "rh_age_read_br", 
    "rh_read_b4_yng_br", 
    "rh_read_since_yng_br", 
    "rh_read_b4_old_br", 
    "rh_read_with_b4_old_br", 
    "rh_readin_b4_old_br", 
    "rh_read_since_old_br", 
    "rh_read_w_since_old_br", 
    "rh_readin_since_old_br", 
    "rh_read_time_b4_br",
    "rh_read_time_since_br",
    "hlr_books_b4_corrected", 
    "hlr_dbooks_b4_corrected",
    "hlr_games_b4_corrected",
    "hlr_dgames_b4_corrected",
    "hlr_ad_books_b4_corrected",
    "hlr_ad_dbooks_b4_corrected",
    "hlr_ad_news_b4_corrected",
    "hlr_books_since_corrected",
    "hlr_dbooks_since_corrected",
    "hlr_games_since_corrected",
    "hlr_dgames_since_corrected",
    "hlr_ad_books_since_corrected",
    "hlr_ad_dbooks_since_corrected",
    "hlr_ad_news_since_corrected",
    "ea_read_b4_ALL_br",
    "ea_indr_b4_ALL_br",
    "ea_letter_b4_yng_br",
    "ea_tv_b4_yng_br",
    "ea_boardg_b4_yng_br",
    "ea_vidg_b4_yng_br",
    "ea_edapp_b4_yng_br",
    "ea_read_since_yng_br",
    "ea_indr_since_yng_br",
    "ea_letter_since_yng_br",
    "ea_tv_since_yng_br",
    "ea_boardg_since_yng_br",
    "ea_vidg_since_yng_br",
    "ea_edapp_since_yng_br")

# Remoção dos registros que contêm valores NA
db_out_na <- db_blocos[rowSums(is.na(db_blocos)) < 1, ]

```

<!-- Início Capa -->

<h1 align="center">**Projeto LabEst: Consultoria em Análise Estatística para Alunos de Pós-Graduação**</h1>
<br />
<br />

<h3 align="center">**Relatório Preliminar da Análise Estatística:**</h3>
<h3 align="center">Literacia Familiar no período pré e pandêmico de Covid-19: cenário brasileiro e estratégias de intervenção</h3>
<br />
<br />

<h5 align="center">**Cliente**:</h5>
<br />

<h5 align="center">Natália Viana</h5>
<h5 align="center">Mestranda em Psicologia: Cognição e Comportamento - Faculdade de Filosofia e Ciências Humanas da Universidade Federal de Minas Gerais</h5>
<br />
<br />

<h5 align="center">**Consultores**</h5>
<br />

<h5 align="center">Bianca Caravelli de Sá</h5>
<h5 align="center">Luiz Felipe Avelar</h5>
<h5 align="center">Thomás de Santiago Silva</h5>
<h5 align="center">Alunos da Disciplina “Laboratório de Estatística I”</h5>
<br />

<h5 align="center">**Orientação: Prof. Adrian Luna**</h5>
<br />

<h5 align="center">**15/07/2022**</h5>
<br />

<!-- Fim Capa -->

<!-- INÍCIO Introdução e metodologia -->

<br />

## 1) **Introdução e metodologia**

<br />

<font size="4"> 

<p style='text-align: justify;'> 
O objetivo dessa tese de doutorado é investigar o impacto da pandemia de COVID-19 nas práticas e recursos de literacia familiar no contexto brasileiro, ou seja, investigar as práticas de leitura e letramento feitas por pais e responsáveis com crianças pequenas feitas em casa durante o período de quarentena e o impacto para o desenvolvimento da alfabetização dessas crianças em um momento em que as escolas encontravam-se fechadas.

Para a obtenção dos dados, foi aplicado o questionário "Examinando a influência das restrições da COVID-19 no ambiente de literacia familiar" que consiste em perguntas de interesse que descrevem o perfil demográfico e socioeconômico dessas famílias, assim como os hábitos e atividades de literacia desenvolvidas no ambiente familiar.

A partir desses dados obtidos no questionário, as análises do dados encontram-se divididas em duas partes, a primeira consiste em uma análise descritiva, através de gráficos de barra, histogramas, boxplots e tabelas de frequência, das váriaveis de interesse principal que podem impactar os hábitos de literacia durante a pandemia. Cada variável foi analisada de maneira individual, sendo elas:
</p>
  
  - Região de residência
  
  - Raça
  
  - Nível educacional do respondente
  
  - Nível Socioeconômico da família - renda familiar
  
  - Situação profissional do respondente antes e depois da covid
  
  - Quantidade de cuidadores
  
  - Quantidade de crianças
  
  - Tipo de quarentena
  
  - Nível de estresse com o isolamento
  
<p style='text-align: justify;'> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Já a segunda parte consiste em análises fatorial exploratórias a partir de blocos de perguntas a fim de reduzir a quantidade de variávies e obter indíces que explicam a variabilidade dos dados. As variáveis de interesse para essa análise foram divididas nos seguintes blocos:
</p>
  
  - Bloco 1 - Bloco Reading History Br (Histórico de alfabetização)
  
  - Bloco 2 - Home Literacy Resources Br (Recursos)
  
  - Bloco 3 - Enrichment Activities Br (Atividades de enriquecimento)

</font>  
<!-- FIM Introdução e metodologia -->

<!-- INÍCIO Resultados -->

<br />

## 2) **Análise Exploratória**

### **Região de residência**

```{r, include=FALSE}
# Contagem dos valores NAs na variável
sum(is.na(db$geographic_region_br))
```

<font size="4"> 
<p style='text-align: justify;'> 
Pode-se observar que a grande maioria, 73,45%, das pessoas que respoderam ao questionário moram na região Sudeste do Brasil, enquanto que apenas 2,55% são residentes da região Centro-Oeste. Esta variável possui 931 observações NAs.
</p>
</font>
<br />

```{r, fig.cap = "Figura 1 - Região de residência"}
# Plot do gráfico de barras para a variável residência
# primeiro  manipula-se a variável, remove-se os NAs, depois conta a quantidade de respostas por região, transforma essa contagem em uma porcentagem e reescreve as categorias como os nomes das respectivas regiões.
plotdata <- db %>%
   filter(!is.na(geographic_region_br)) %>%
  count(geographic_region_br) %>%
  dplyr::mutate(pct = n / sum(n),
         pctlabel = paste0(round(pct * 100, 2), "%"),
         geographic_region_br = recode(geographic_region_br, 
                                          `0` = "Sul", 
                                          `1` = "Sudeste", 
                                          `2` = "Centro-Oeste", 
                                          `3` = "Nordeste", 
                                          `4` = "Norte"
                                          ))

# Plot da vatiável manipulada acima, define-se o tamanhos e o texto de cada eixo e as cores do grafico
ggplot(plotdata, 
       aes(x = reorder(geographic_region_br, -pct),
           y = pct)) + 
  geom_bar(stat = "identity", 
           fill = "indianred3", 
           color = "black") +
  scale_y_continuous(limits = c(0,0.8)) +
  geom_text(aes(label = pctlabel), 
            vjust = -0.25) +
  labs(x = "Região", 
       y = "Porcentagem")+
  ggtitle("Região de residência") +
  theme(plot.title = element_text(size=10, hjust = 0.5))
```

### **Raça**

<font size="4"> 
<p style='text-align: justify;'> 
Pode-se observar que 87,92% das crianças são brancas ou pardas, sendo a raça branca a mais frequente. Para esta variável houve 931 obervações NAs.
</p
</font>
<br />

```{r, fig.cap = "Figura 2 - Raça"}
plotdata <- db %>%
   filter(!is.na(races_categorized)) %>%
  count(races_categorized) %>%
  mutate(pct = n / sum(n),
         pctlabel = paste0(round(pct * 100, 2), "%"),
         races_categorized = recode(races_categorized, 
                                          `0` = "Branco(a)", 
                                          `1` = "Pardo(a)", 
                                          `2` = "Preto(a)", 
                                          `3` = "Amarelo(a)", 
                                          `4` = "Indígena",
                                          `5` = "Outro(a)",
                                          `6` = "N/S",
                                          `7` = "Duas ou mais",
                                          ))

ggplot(plotdata, 
       aes(x = reorder(races_categorized, -pct),
           y = pct)) + 
  geom_bar(stat = "identity", 
           fill = "indianred3", 
           color = "black") +
  scale_y_continuous(limits = c(0,0.8)) +
  geom_text(aes(label = pctlabel), 
            vjust = -0.25) +
  labs(x = "Raças", 
       y = "Porcentagem")+
  ggtitle("Raças") +
  theme(plot.title = element_text(size=10, hjust = 0.5))
```


### **Nível educacional do respondente**

```{r, include=FALSE}
sum(is.na(db$highest_degree_ALL_br_y))
```

<font size="4"> 
<p style='text-align: justify;'> 
Pode-se observar que a maioria dos respondentes do questionário possuem um nível educacional alto, sendo que 51,55% possuem pós-graduação, enquanto que apenas 1,01% dos respondentes possuiem Ensino Fundamental completo ou incompleto.

Vale ressaltar que 931 pessoas não responderam a essa pergunta.
</p>
</font>
<br />

```{r, fig.cap = "Figura 3 - Nível educacional do respondente"}
plotdata <- db %>%
   filter(!is.na(highest_degree_ALL_br_y)) %>%
  count(highest_degree_ALL_br_y) %>%
  mutate(pct = n / sum(n),
         pctlabel = paste0(round(pct * 100, 2), "%"),
         highest_degree_ALL_br_y = recode(highest_degree_ALL_br_y, 
                                          `0` = "EF", 
                                          `1` = "EM - Inc", 
                                          `2` = "EM - Comp", 
                                          `3` = "ES - Inc", 
                                          `4` = "ES - Técnologo",
                                          `5` = "ES - Comp",
                                          `6` = "Pós-grad",
                                          `7` = "N/S",
                                          `8` = "Não aplicável"
                                          ))

ggplot(plotdata, 
       aes(x = reorder(highest_degree_ALL_br_y, -pct),
           y = pct)) + 
  geom_bar(stat = "identity", 
           fill = "indianred3", 
           color = "black") +
  scale_y_continuous(limits = c(0,0.6)) +
  geom_text(aes(label = pctlabel), 
            vjust = -0.25) +
  labs(x = "Nível educacional", 
       y = "Porcentagem")+
  ggtitle("Nível educacional do respondente") +
  theme(plot.title = element_text(size=10, hjust = 0.5))
```


### **Nível Socioeconômico da família - Renda familiar**

<br />
<font size="4"> 
<p style='text-align: justify;'> 
Em relação a renda familiar, pode-se observar que possui uma distribuição com consideráveis valores outliers, os gráficos abaixo possuem duas versões, sendo a primeira os valores originais e a segunda removendo os outliers. A renda mediana familiar é de R$ 7000,00 e 978 pessoas não responderam a essa questão.
</p>
</font>
<br />

```{r, include=FALSE}
options(scipen=10000)
# median(db_without_na_income$household_income_br)
sum(is.na(db$household_income_br))
```


```{r, fig.cap = "Figura 4 - Renda familiar"}
# Remoção dos valores NAs da variável
db_without_na_income <- db %>% drop_na(household_income_br)

# Cálculo do do 1º e 3º quartil, assim como da distância interquartilica
Q1 <- quantile(db_without_na_income$household_income_br, .25)
Q3 <- quantile(db_without_na_income$household_income_br, .75)
IQR <- IQR(db_without_na_income$household_income_br)

# Remição dos valoresoutliers
db_witout_income_outliers <- subset(db_without_na_income, db_without_na_income$household_income_br > (Q1 - 1.5 * IQR) & db_without_na_income$household_income_br < (Q3 + 1.5*IQR))

# Configuração para plotar os gráficos lado a lado
par(mfrow=c(1, 2))

# Plot do boxplot com todos os valores
boxplot(
  db_without_na_income$household_income_br,
  ylab = "Renda (em reais)", 
  main = "Renda familiar",
  col = "indianred3"
)

# Plot do boxplot sem os valores outliers
boxplot(
  db_witout_income_outliers$household_income_br,
  ylab = "Renda (em reais)", 
  main = "Renda familiar",
  col = "indianred3"
)
```

```{r, fig.cap = "Figura 5 - Renda familiar"}
par(mfrow=c(1, 2))

# Plot do histograma com outliers
hist(db$household_income_br,
  main = "Renda Familiar",
  xlab = "Renda (em reais)",
  ylab = "Número de residências",
  col = "indianred3",
  freq=TRUE
)

# Plot do histograma sem outliers
hist(db_witout_income_outliers$household_income_br,
  main = "Renda Familiar",
  xlab = "Renda (em reais)",
  ylab = "Número de residências",
  col = "indianred3",
  freq=TRUE
)
```

### **Situação profissional do respondente antes e depois da covid**

```{r, include=FALSE}
sum(is.na(db$bg_restrictions_br___0))
```

<br />
<font size="4"> 
<p style='text-align: justify;'> 
Para as duas questões sobre situação profissional, há 12 opções de resposta, sendo elas:
</p>

0 - Eu trabalhava em tempo integral fora de casa (mais do que 40 horas por semana)

1 - Eu trabalhava em tempo integral em casa (mais do que 40 horas por semana)

2 - Eu trabalhava em tempo integral, parcialmente em casa e parcialmente fora de casa (mais do que 40 horas por semana)

3 - Eu trabalhava meio período fora de casa (menos que 40 horas por semana) 

4 - Eu trabalhava meio período em casa (menos que 40 horas por semana) 

5 - Estudante 

6 - Eu estava em licença de trabalho temporária (por exemplo suspenso do trabalho, licença maternidade)

7 - Era dono(a) de casa ou cuidava das crianças em tempo integral

8 - Desempregado

9 - Aposentado 

10 - Beneficiário do INSS 

11 - Prefiro não responder

<p style='text-align: justify;'> 
Pode-se observar que a grande maioria dos respondentes possuia um emprego integral fora de casa anteriormente ao COVID-19, assim que a pandemia se inicia há uma mudança na distribuição dos tipos de emprego e o trabalho em casa passa a ser a categoria mais frequente.
</p>
</font>
<br />

```{r, fig.cap = "Figura 6 - Emprego pré pandemia"}
# Construção de uma variável auxiliar para o agrupamento das respostas para cada alternativa no questionário
job_before <- c(
  rep("0", sum(db$bg_job_b4_br___0_y, na.rm = TRUE)),
  rep("1", sum(db$bg_job_b4_br___1_y, na.rm = TRUE)),
  rep("2", sum(db$bg_job_b4_br___2_y, na.rm = TRUE)),
  rep("3", sum(db$bg_job_b4_br___3_y, na.rm = TRUE)),
  rep("4", sum(db$bg_job_b4_br___4_y, na.rm = TRUE)),
  rep("5", sum(db$bg_job_b4_br___5_y, na.rm = TRUE)),
  rep("6", sum(db$bg_job_b4_br___6_y, na.rm = TRUE)),
  rep("7", sum(db$bg_job_b4_br___7_y, na.rm = TRUE)),
  rep("8", sum(db$bg_job_b4_br___8_y, na.rm = TRUE)),
  rep("9", sum(db$bg_job_b4_br___9_y, na.rm = TRUE)),
  rep("10", sum(db$bg_job_b4_br___10_y, na.rm = TRUE)),
  rep("11", sum(db$bg_job_b4_br___11_y, na.rm = TRUE))
)

# Plot da tabela de freqûencia mais gráfico de barras
tab1(job_before, decimal = 2, cum.percent = TRUE, graph = TRUE, main = "Emprego antes da pandemia", xlab = "Tipo de emprego", ylab = "Número de observações")
```

```{r, fig.cap = "Figura 7 - Emprego na pandemia"}
job_after <- c(
  rep("0", sum(db$bg_job_since_br___0_y, na.rm = TRUE)),
  rep("1", sum(db$bg_job_since_br___1_y, na.rm = TRUE)),
  rep("2", sum(db$bg_job_since_br___2_y, na.rm = TRUE)),
  rep("3", sum(db$bg_job_since_br___3_y, na.rm = TRUE)),
  rep("4", sum(db$bg_job_since_br___4_y, na.rm = TRUE)),
  rep("5", sum(db$bg_job_since_br___5_y, na.rm = TRUE)),
  rep("6", sum(db$bg_job_since_br___6_y, na.rm = TRUE)),
  rep("7", sum(db$bg_job_since_br___7_y, na.rm = TRUE)),
  rep("8", sum(db$bg_job_since_br___8_y, na.rm = TRUE)),
  rep("9", sum(db$bg_job_since_br___9_y, na.rm = TRUE)),
  rep("10", sum(db$bg_job_since_br___10_y, na.rm = TRUE)),
  rep("11", sum(db$bg_job_since_br___11_y, na.rm = TRUE))
)

tab1(job_after, decimal = 2, cum.percent = TRUE, graph = TRUE, main = "Emprego na pandemia", xlab = "Tipo de emprego", ylab = "Número de observações")
```


### **Quantidade de cuidadores**

<font size="4"> 
<p style='text-align: justify;'> 
Pode-se observar que das 2223 respostas ao questionário, 2085 respostas foram de residências que possuem cuidadores.
</p>
</font>
<br />

```{r, include=FALSE}
sum(is.na(db$bg_caregivers_b4_br))
```


```{r, fig.cap = "Figura 8 - Quantidade de cuidadores"}
# Remoção dos valores outliers
Quantidade_de_cuidadores <- db %>% dplyr::select(bg_caregivers_b4_br) %>% drop_na()

tab1(Quantidade_de_cuidadores, decimal = 2, cum.percent = TRUE, graph = TRUE, main = "Quantidade de cuidadores por residência", xlab = "Número de cuidadores", ylab = "Número de residências")
```

### **Quantidade de crianças**

<br />
<font size="4"> 
<p style='text-align: justify;'> 
Pode-se observar que a maioria das residências possuem duas ou menos crianças, sendo que apenas 48 delas possuem quatro ou mais crianças. Para esta variável há 47 observações NAs.
</p>
</font>
<br />

```{r, include=FALSE}
sum(is.na(db$bg_num_children_br))
```


```{r, fig.cap = "Figura 9 - Quantidade de crianças"}
Quantidade_de_criancas <- db %>% dplyr::select(bg_num_children_br) %>% drop_na()

tab1(Quantidade_de_criancas, decimal = 2, sort.group = "decreasing", cum.percent = TRUE, graph = TRUE, main = "Quantidade de crianças por residência", xlab = "Número de crianças", ylab = "Número de residências")
```


### **Tipo de quarentena**

<font size="4"> 
Para o tipo de quarentena e restrições recomendadas à família, temos as seguintes opções:

0 - Não há restrições agora 

1 - Quarentena voluntária 

2 - Pedido ou aviso depermanência em casa pelo governo local (caminhadas ou passeios com distanciament osocial permitidos) 

3 - Pedido de permanência em casa pelo governo local (só saia de casa para fins essenciais) 

4 - Outro

Pode-se observar que o tipo 3 foi o mais frequente, enquanto que o tipo 0 foi o menos frequente.

</font>
<br />

```{r, include=FALSE}
sum(is.na(db$bg_restrictions_br___0))
```


```{r, fig.cap = "Figura 10 - Restrições familiares na pandemia"}
restrictions <- c(
  rep("Tipo 0", sum(db$bg_restrictions_br___0, na.rm = TRUE)),
  rep("Tipo 1", sum(db$bg_restrictions_br___1, na.rm = TRUE)),
  rep("Tipo 2", sum(db$bg_restrictions_br___2, na.rm = TRUE)),
  rep("Tipo 3", sum(db$bg_restrictions_br___3, na.rm = TRUE)),
  rep("Tipo 4", sum(db$bg_restrictions_br___4, na.rm = TRUE))
)

tab1(restrictions, decimal = 2, cum.percent = TRUE, graph = TRUE, main = "Tipo de quarentena", xlab = "Tipo de quarentena", ylab = "Número de observações")
```


### **Nível de estresse com o isolamento**

<br />
<font size="4"> 

Para o nível de estresse com o isolamento, tem-se as seguintes categorias:

0 - Não tem - Não tem sido estressante

1 - Pouco - Um pouco estressante

2 - Estressante - Estressante

3 - Muito - Muito estressante

4 - Extremamente - Extremamente estressante

<p style='text-align: justify;'> 
Pode-se notar que apenas 175 das respostas consideram que o isolamento não tem sido estressante, enquanto 712 o consideram pouco estressante.
</p>
</font>
<br />

```{r, fig.cap = "Figura 11 - Nível de estresse com o isolamento"}
stress <- c(
  rep("Não tem", sum(db$bg_home_stress_br___0, na.rm = TRUE)),
  rep("Pouco", sum(db$bg_home_stress_br___1, na.rm = TRUE)),
  rep("Estressante", sum(db$bg_home_stress_br___2, na.rm = TRUE)),
  rep("Muito", sum(db$bg_home_stress_br___3, na.rm = TRUE)),
  rep("Extremamente", sum(db$bg_home_stress_br___4, na.rm = TRUE))
)

tab1(stress, decimal = 2, cum.percent = TRUE, graph = TRUE, main = "Nível de estresse com o isolamento", xlab = "Nível", ylab = "Número de observações")
```

<br />

## 3) **Análise Fatorial - PCA e MCA**

<br />

<font size="4"> 
<p style='text-align: justify;'> 
Ao trabalhar com um grande número de variáveis, a matriz de correlação agrupa uma grande quantidade de coeficientes (190 coeficientes para K = 20 variáveis). É, portanto, essencial ter uma ferramenta capaz de resumir as principais relações entre as variáveis de forma visual. 

O objetivo do **PCA** é tirar conclusões das relações lineares entre variáveis detectando as dimensões principais de variabilidade. Como será analisado, estas conclusões serão complementadas pela definição das variáveis sintéticas oferecidas pelo PCA. Portanto, será mais fácil descrever os dados usando algumas variáveis sintéticas em vez de todas as variáveis originais.

Assim como na análise de componentes principais (PCA), o objetivo é resumir as relações entre as variáveis. Essas relações são estudadas em pares ou todas juntas. Neste último caso, procuramos variáveis sintéticas que resumem as informações contidas em um número de variáveis. A informação transportada por uma variável pode ser estudada em termosde suas categorias. Na **MCA**, focamos principalmente no estudo das categorias, como categorias representam tanto variáveis quanto um grupo de indivíduos (todos os indivíduos que selecionam esta categoria).
</p>
</font>

<br />

### **Bloco 1 - Histórico de alfabetização**

<br />

| Pré Covid | Com Covid |
| --------- | --------- | 
| rh_read_b4_yng_br | rh_read_since_yng_br  |
| rh_read_b4_old_br | rh_read_since_old_br  |
| rh_read_with_b4_old_br | rh_read_w_since_old_br |
| rh_readin_b4_old_br | rh_readin_since_old_br |
| rh_read_time_b4_br | rh_read_time_since_br |

<br />

```{r, echo=FALSE, include=FALSE}
# Importe dos pacotes necessários para o MCA
require(FactoMineR)
require(stringr)
library(data.table)
library(car)
require(corrplot)
library(psych)
library(FactoMineR)
require(FactoInvestigate)
library(factoextra)

# Seleção das vairáveis que compõem os blocos
db_bloco_1 <- db_out_na %>% 
  dplyr::select(
    "rh_age_read_br",
    "rh_read_b4_yng_br", 
    "rh_read_since_yng_br",
    "rh_read_b4_old_br",
    "rh_read_with_b4_old_br",
    "rh_readin_b4_old_br",
    "rh_read_since_old_br", 
    "rh_read_w_since_old_br",
    "rh_readin_since_old_br", 
    "rh_read_time_b4_br",
    "rh_read_time_since_br"
  )

db_bloco_1_pre <- db_bloco_1 %>% 
  dplyr::select(
    "rh_read_b4_yng_br",
    "rh_read_b4_old_br",
    "rh_read_with_b4_old_br",
    "rh_readin_b4_old_br",
    "rh_read_time_b4_br"
  )

db_bloco_1_pos <- db_bloco_1 %>% 
  dplyr::select(
    "rh_read_since_yng_br",
    "rh_read_since_old_br",
    "rh_read_w_since_old_br",
    "rh_readin_since_old_br",
    "rh_read_time_since_br"
  )
colnames(db_bloco_1)<- c(
  "rh_age_read_br",
  "read",
  "read_",
  "read_1",
  "read_2",
  "read_3",
  "read_4",
  "read_5",
  "read_6",
  "read_7",
  "read_8"
)

colnames(db_bloco_1_pre) <- c(
  "read",
  "read_",
  "read_1",
  "read_2",
  "read_3"
)

colnames(db_bloco_1_pos) <- c(
  "read_4",
  "read_5",
  "read_6",
  "read_7",
  "read_8"
)

```

> Correlação entre as variáveis do bloco:

<br />

#### Bloco Pré Pandemia

#### Bloco Pós Pandemia

```{r}
matcor_pre_1 <- cor(db_bloco_1_pre)
matcor_pos_1 <- cor(db_bloco_1_pos)
t_pre <- "Pré Pandemia"
t_pos <- "Pós Pandemia"
par(mfrow=c(1, 2))
corrplot(matcor_pre_1, method="circle", type = "upper", diag = FALSE, title = t_pre, addCoef.col = "black", mar=c(0,0,2,0))
corrplot(matcor_pos_1, method="circle", type = "upper", diag = FALSE, title = t_pos, addCoef.col = "black", mar=c(0,0,2,0))
```

<br />

### **Multiple Correspondence Analysis**

O MCA geralmente é usado para analisar um conjunto de dados de uma pesquisa. O objetivo é identificar:

1 - Um grupo de indivíduos com perfil semelhante em suas respostas às perguntas

2 - As associações entre categorias de variáveis

<p style='text-align: justify;'> 
Calcular e visualizar a análise de correspondência múltipla no software R usando *FactoMineR* (para a análise) e *factoextra* (para visualização de dados).

Revelar as variáveis mais importantes que mais contribuem para explicar as variações no conjunto de dados explicando como prever os resultados para indivíduos e variáveis suplementares. Filtrar os resultados do MCA para manter apenas as variáveis que mais contribuíram.
</p>

<br />

#### **Pré Pandemia**

```{r, echo=FALSE, include=FALSE}
# Transformação das variáveis para a classe fator (para o R tratá-las como variáveis categóricas)
db_bloco_1_pref <- as.data.frame(lapply(db_bloco_1_pre, as.factor))
```

```{r}
# Medidas resumo das variáveis
summary(db_bloco_1_pref)
```

```{r}
# Plot de gráficos de barras para a quantidade de respostas por categoria por variável 
par(mfrow=c(2, 3))
plot(db_bloco_1_pref[,1], 
     main=colnames(db_bloco_1_pref)[1],
     ylab = "Count",
     col="steelblue",
     las = 2)
plot(db_bloco_1_pref[,2], 
                  main=colnames(db_bloco_1_pref)[2],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_1_pref[,3], 
                  main=colnames(db_bloco_1_pref)[3],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_1_pref[,4], 
                  main=colnames(db_bloco_1_pref)[4],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_1_pref[,5], 
                  main=colnames(db_bloco_1_pref)[5],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
  
```

> Construindo o MCA

As variáveis podem ser representadas calculando as razões de correlação entre as coordenadas dos indivíduos em um componente e cada uma das categorias.


```{r}
# Ajuste do MCA
res.mca_1 <- MCA(db_bloco_1_pref, ncp = 5, graph = TRUE)
```

> Visualização e interpretação

Estudar a inércia dos componentes principais permite-nos, por um lado, ver se as variáveis estão estruturadas (presença de correlações entre
variáveis) e, além disso, determinar o número de componentes a serem interpretados. 

Os resultados em abaixo, produzidos em um gráfico de barras, correspondem ao autovalor (ou seja, a inércia ou a variação explicada) associada a cada um dos componentes; a porcentagem de inércia associada a cada componente e a soma cumulativa dessas porcentagens.


> Porcentagens de inércia explicadas por cada dimensão MCA

```{r}
# Plot dos 10 maiores autovalores
fviz_screeplot(res.mca_1, addlabels = TRUE, ylim = c(0, 10))
```

```{r}
# Plot do quanto as duas principais componentes explicam cada uma das variávies
fviz_mca_var(res.mca_1, choice = "mca.cor", 
            repel = TRUE, # Avoid text overlapping (slow)
            ggtheme = theme_minimal())
```

Se uma categoria de variável é bem representada por duas dimensões, a soma do cos2 é próxima de um. Para alguns dos itens de linha, são necessárias mais de 2 dimensões para representar perfeitamente os dados.

 > OS COSSENOS SAO MUITO BAIXOS!
 
```{r}
# Plot da representação de quão bem as duas principais dimensões representam cada uma das categorias de cada variável
fviz_mca_var(res.mca_1, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE, # Avoid text overlapping
             ggtheme = theme_minimal())
```

```{r}
# Plot dos cossenos por categoria de resposta de cada variável
fviz_cos2(res.mca_1, choice = "var", axes = 1:2)
```

15 principais categorias de variáveis que contribuem para as dimensões:

```{r}
# Dentre das 15 principais categorias do gráfico anterior, o plot de quanto elas contribuiem para as duas maiores dimensões
par(mfrow=c(2, 1))
# Contributions of rows to dimension 1
fviz_contrib(res.mca_1, choice = "var", axes = 1, top = 15)
# Contributions of rows to dimension 2
fviz_contrib(res.mca_1, choice = "var", axes = 2, top = 15)
```

#### **Pós Pandemia**

```{r, echo=FALSE, include=FALSE}
db_bloco_1_posf <- as.data.frame(lapply(db_bloco_1_pos, as.factor))
```

```{r}
summary(db_bloco_1_posf)
```

```{r}
par(mfrow=c(2, 3))
plot(db_bloco_1_posf[,1], 
     main=colnames(db_bloco_1_posf)[1],
     ylab = "Count",
     col="steelblue",
     las = 2)
plot(db_bloco_1_pref[,2], 
                  main=colnames(db_bloco_1_posf)[2],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_1_posf[,3], 
                  main=colnames(db_bloco_1_posf)[3],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_1_posf[,4], 
                  main=colnames(db_bloco_1_posf)[5],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_1_posf[,5], 
                  main=colnames(db_bloco_1_posf)[5],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
  
```

> Construindo o MCA

As variáveis podem ser representadas calculando as razões de correlação entre as coordenadas dos indivíduos em um componente e cada uma das categorias.


```{r}
res.mca_1 <- MCA(db_bloco_1_posf, ncp = 5, graph = TRUE)
```

> Visualização e interpretação

Estudar a inércia dos componentes principais permite-nos, por um lado, ver se as variáveis estão estruturadas (presença de correlações entre
variáveis) e, além disso, determinar o número de componentes a serem interpretados. 

Os resultados em abaixo, produzidos em um gráfico de barras, correspondem ao autovalor (ou seja, a inércia ou a variação explicada) associada a cada um dos componentes; a porcentagem de inércia associada a cada componente e a soma cumulativa dessas porcentagens.


> Porcentagens de inércia explicadas por cada dimensão MCA

```{r}
fviz_screeplot(res.mca_1, addlabels = TRUE, ylim = c(0, 10))

```

```{r}
fviz_mca_var(res.mca_1, choice = "mca.cor", 
            repel = TRUE, # Avoid text overlapping (slow)
            ggtheme = theme_minimal())
```

Se uma categoria de variável é bem representada por duas dimensões, a soma do cos2 é próxima de um. Para alguns dos itens de linha, são necessárias mais de 2 dimensões para representar perfeitamente os dados.

 > OS COSSENOS SAO MUITO BAIXOS!
 
```{r}
fviz_mca_var(res.mca_1, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE, # Avoid text overlapping
             ggtheme = theme_minimal())
```

```{r}
fviz_cos2(res.mca_1, choice = "var", axes = 1:2)
```

15 principais categorias de variáveis que contribuem para as dimensões:

```{r}
par(mfrow=c(2, 1))
# Contributions of rows to dimension 1
fviz_contrib(res.mca_1, choice = "var", axes = 1, top = 15)
# Contributions of rows to dimension 2
fviz_contrib(res.mca_1, choice = "var", axes = 2, top = 15)
```

### **Bloco 2 - Recursos de alfabetização inicial**

```{r}
db_bloco_2 <- db_out_na %>% 
  dplyr::select(
    "hlr_books_b4_corrected", 
    "hlr_dbooks_b4_corrected",
    "hlr_games_b4_corrected",
    "hlr_dgames_b4_corrected",
    "hlr_ad_books_b4_corrected",
    "hlr_ad_dbooks_b4_corrected",
    "hlr_ad_news_b4_corrected",
    "hlr_books_since_corrected",
    "hlr_dbooks_since_corrected",
    "hlr_games_since_corrected",
    "hlr_dgames_since_corrected",
    "hlr_ad_books_since_corrected",
    "hlr_ad_dbooks_since_corrected",
    "hlr_ad_news_since_corrected" 
  )

db_bloco_2_pre <- db_bloco_2 %>% 
  dplyr::select(
    "hlr_books_b4_corrected", 
    "hlr_dbooks_b4_corrected",
    "hlr_games_b4_corrected",
    "hlr_dgames_b4_corrected",
    "hlr_ad_books_b4_corrected",
    "hlr_ad_dbooks_b4_corrected",
    "hlr_ad_news_b4_corrected"
  )

db_bloco_2_pos <- db_bloco_2 %>% 
  dplyr::select(
    "hlr_books_since_corrected",
    "hlr_dbooks_since_corrected",
    "hlr_games_since_corrected",
    "hlr_dgames_since_corrected",
    "hlr_ad_books_since_corrected",
    "hlr_ad_dbooks_since_corrected",
    "hlr_ad_news_since_corrected" 
  )
colnames(db_bloco_2)<- c("books_b4", 
    "dbooks_b4",
    "games_b4",
    "dgames_b4",
    "ad_books_b4",
     "ad_dbooks_b4",
     "ad_news_b4",
    "books_since", 
    "dbooks_since",
    "games_since",
    "dgames_since",
    "ad_books_since",
     "ad_dbooks_since",
     "ad_news_since")

 colnames(db_bloco_2_pre) <- c("books_b4", 
    "dbooks_b4",
    "games_b4",
    "dgames_b4",
    "ad_books_b4",
     "ad_dbooks_b4",
     "ad_news_b4")
 
  colnames(db_bloco_2_pos) <- c("books_since", 
    "dbooks_since",
    "games_since",
    "dgames_since",
    "ad_books_since",
     "ad_dbooks_since",
     "ad_news_since")
```


> Mapa de calor para a correlação entre as variáveis do bloco 2



```{r}
matcorr_pre_2 <- cor(db_bloco_2_pre)
matcorr_pos_2 <- cor(db_bloco_2_pos)
t_pre <- "Pré Pandemia"
t_pos <- "Pós Pandemia"
par(mfrow=c(1, 2))
corrplot(matcorr_pre_2, method="circle", type = "upper", diag = FALSE, title = t_pre, addCoef.col = "black", mar=c(0,0,2,0))
corrplot(matcorr_pos_2, method="circle", type = "upper", diag = FALSE, title = t_pos, addCoef.col = "black", mar=c(0,0,2,0))
```


```{r}

corrplot(matcorr_pos_2, method="circle", type = 'upper')
```

#### Pré Pandemia

```{r}
db_bloco_2_pref <- as.data.frame(lapply(db_bloco_2_pre, as.factor))
```

Pelas frequências das categorias, a maioria dos recursos se concentram nas quantidades das categoria até 1. Apenas livros para crianças e adultos apresentam quantidades maiores.
```{r}
for (i in 1:7) {
plot(db_bloco_2_pref[,i], main=colnames(db_bloco_2_pref)[i],
       ylab = "Count", col="steelblue", las = 2)
  }
```

```{r}
par(mfrow=c(2, 4))
plot(db_bloco_2_pref[,1], 
     main=colnames(db_bloco_2_pref)[1],
     ylab = "Count",
     col="steelblue",
     las = 2)
plot(db_bloco_2_pref[,2], 
                  main=colnames(db_bloco_2_pref)[2],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_2_pref[,3], 
                  main=colnames(db_bloco_2_pref)[3],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_2_pref[,4], 
                  main=colnames(db_bloco_2_pref)[4],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_2_pref[,5], 
                  main=colnames(db_bloco_2_pref)[5],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_2_pref[,5], 
                  main=colnames(db_bloco_2_pref)[6],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_2_pref[,5], 
                  main=colnames(db_bloco_2_pref)[7],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
```

```{r}
levels(db_bloco_2_pref$ad_news_b4)[4] <- (db_bloco_2_pref$ad_news_b4)[3]
```

Há um grupo indivíduos (na extremidade positiva do segundo
principal componente) muito próximos, pois compartilham muitas categorias em comuns.
Assim como na extremidade negativa.

Já a primeira principal componente parece explicar um grupo seleto de pessoas.

Analisando pelas categorias, o primeiro grupo citado apresenta categorias de quantidade entre 2 e 6 na sua extremidade,
no segundo as categorias as extremidades se concetram em zero.
E o terceiro categorias em 7.
Além disso parece haver um grupo naa1aaa2ão bem explicado em ambas.

> Construindo MCA

```{r, include=FALSE}
res.mca_pref <- MCA(db_bloco_2_pref,ncp = 5, graph = TRUE ) 
```

```{r}
fviz_mca_biplot(res.mca_pref, 
               repel = TRUE, # Avoid text overlapping (slow if many point)
               ggtheme = theme_minimal(),
              xlim = c(-2,6),
              ylim= c(-4,2))
```

A variável **hlr_ad_news_b4** é a menos correlacionada com ambas dimensões.
As demais variáveis sao próximas nos dos primeiros componentes. 

```{r}
fviz_mca_var(res.mca_pref, choice = "mca.cor", 
            repel = TRUE, # Avoid text overlapping (slow)
            ggtheme = theme_minimal())
```

```{r}
fviz_mca_var(res.mca_pref, 
             repel = TRUE, # Avoid text overlapping (slow)
             ggtheme = theme_minimal(),
              xlim = c(-2,6),
              ylim= c(-4,2))
```

As 5 primeiras dimensões juntas explicam cerca de 25% da variância dos dados.
E as 2 primeiras 12%.
Porcentagens de inércia explicadas por cada dimensão MCA

```{r}
fviz_screeplot(res.mca_pref, addlabels = TRUE, ylim = c(0, 10))
```
15 principais categorias de variáveis que contribuem para as dimensões:

```{r}
# Contributions of rows to dimension 1
fviz_contrib(res.mca_pref, choice = "var", axes = 1, top = 15)
# Contributions of rows to dimension 2
fviz_contrib(res.mca_pref, choice = "var", axes = 2, top = 15)
```

```{r}
fviz_mca_var(res.mca_pref, alpha.var="contrib",
             repel = TRUE,
             ggtheme = theme_minimal())
```


#### Pós Pandemia

```{r}
db_bloco_2_posf <- as.data.frame(lapply(db_bloco_2_pos, as.factor))
```

<!-- Pelas frequências das categorias, a maioria dos recursos se mantiveram com a mesma quantidade pos-pandemia.  -->
<!-- ```{r} -->

<!-- for (i in 1:7) { -->
<!-- plot(db_bloco_2_posf[,i], main=colnames(db_bloco_2_posf)[i], -->
<!--        ylab = "Count", col="steelblue", las = 2) -->
<!--   } -->
<!-- ``` -->

Há um grupo indivíduos (na extremidade positiva do segundo
principal componente) muito próximos, pois compartilham muitas categorias em comuns.
Assim como na extremidade negativa.

Já a primeira principal componente parece explicar um grupo seleto de pessoas.

Analisando pelas categorias, o primeiro grupo citado apossenta categorias de quantidade entre 2 e 3 na sua extremidade superior,
no segundo as categorias as extremidades se concetram em zero.
E o terceiro categorias em 7.
Além disso parece haver um grupo naa1aaa2ão bem explicado em ambas.


```{r, include=FALSE}
res.mca_posf <- MCA(db_bloco_2_posf,ncp = 5, graph = TRUE ) 
```

```{r}
fviz_mca_biplot(res.mca_posf, 
               repel = TRUE, # Avoid text overlapping (slow if many point)
               ggtheme = theme_minimal(),
              xlim = c(-2,6),
              ylim= c(-4,2))
```
A variável **hlr_ad_news_since** é a menos correlacionada com ambas dimensões.
As demais variáveis sao próximas nos dos primeiros componentes. 

```{r}
fviz_mca_var(res.mca_posf, choice = "mca.cor", 
            repel = TRUE, # Avoid text overlapping (slow)
            ggtheme = theme_minimal())
```

```{r}
fviz_mca_var(res.mca_posf, 
             repel = TRUE, # Avoid text overlapping (slow)
             ggtheme = theme_minimal(),
              xlim = c(-2,6),
              ylim= c(-4,2))
```

As 5 primeiras dimensões juntas explicam 25.7% da variância dos dados.
E as 2 primeiras 12.5%.
Porcentagens de inércia explicadas por cada dimensão MCA

```{r}
fviz_screeplot(res.mca_posf, addlabels = TRUE, ylim = c(0, 10))
```
15 principais categorias de variáveis que contribuem para as dimensões:

```{r}
# Contributions of rows to dimension 1
fviz_contrib(res.mca_posf, choice = "var", axes = 1, top = 15)
# Contributions of rows to dimension 2
fviz_contrib(res.mca_posf, choice = "var", axes = 2, top = 15)
```

```{r}
fviz_mca_var(res.mca_posf, alpha.var="contrib",
             repel = TRUE,
             ggtheme = theme_minimal())
```

```{r}
fviz_contrib(res.mca_pref, choice = "var", axes = 1, top = 15 )
fviz_contrib(res.mca_posf, choice = "var", axes = 1, top = 15 )
```

```{r}
fviz_contrib(res.mca_pref, choice = "var", axes = 2, top = 15 )
fviz_contrib(res.mca_posf, choice = "var", axes = 2, top = 15 )
```

### **Bloco 3 - Atividades de enriquecimento**

| Pré Covid | Com Covid |
| --------- | --------- |

| ea_read_b4_ALL_br | ea_read_since_yng_br |
| ea_indr_b4_ALL_br | ea_indr_since_yng_br |
| ea_letter_b4_yng_br | ea_letter_since_yng_br |
| ea_tv_b4_yng_br | ea_tv_since_yng_br |
| ea_boardg_b4_yng_br | ea_boardg_since_yng_br |
| ea_vidg_b4_yng_br | ea_vidg_since_yng_br |
| ea_edapp_b4_yng_br | ea_edapp_since_yng_br |

```{r}
db_bloco_3 <- db_out_na %>% 
  dplyr::select(
    "ea_read_b4_ALL_br",
    "ea_indr_b4_ALL_br",
    "ea_letter_b4_yng_br",
    "ea_tv_b4_yng_br",
    "ea_boardg_b4_yng_br",
    "ea_vidg_b4_yng_br",
    "ea_edapp_b4_yng_br",
    "ea_read_since_yng_br",
    "ea_indr_since_yng_br",
    "ea_letter_since_yng_br",
    "ea_tv_since_yng_br",
    "ea_boardg_since_yng_br",
    "ea_vidg_since_yng_br",
    "ea_edapp_since_yng_br"
  )

db_bloco_3_pre <- db_bloco_3 %>% 
  dplyr::select(
    "ea_read_b4_ALL_br",
    "ea_indr_b4_ALL_br",
    "ea_letter_b4_yng_br",
    "ea_tv_b4_yng_br",
    "ea_boardg_b4_yng_br",
    "ea_vidg_b4_yng_br",
    "ea_edapp_b4_yng_br"
  )

db_bloco_3_pos <- db_bloco_3 %>% 
  dplyr::select(
    "ea_read_since_yng_br",
    "ea_indr_since_yng_br",
    "ea_letter_since_yng_br",
    "ea_tv_since_yng_br",
    "ea_boardg_since_yng_br",
    "ea_vidg_since_yng_br",
    "ea_edapp_since_yng_br"
  )
```

> Correlação entre as variáveis do bloco:


#### Bloco Pré Pandemia

<br />

Pode-se observar que as variáveis que apresentam maior correlação são justamente aquelas variáveis pré e pós pandemais, tal com 
**ea_read_b4_AAL_br** e **ea_read_since_yng_br** que indicam a frequeência com a que a criança se envolvia em alguma atividade de leitura.

<br />
```{r}
matcorr_3 <- cor(db_bloco_3)
corrplot(matcorr_3, method="circle", type = 'upper')
```

<br />

#### Bloco Pré Pandemia

Pode-se observar que as variávies **ea_read_b4_AAL_br** e **ea_edapp_b4_yng_br** possuem a menor correlação, ou seja, crianças que se envolvem em alguma atividade de leitura e crianças que utilizam algum aplicativo educacional em tablet são pouco correlacionadas, enquanto que as variáveis **ea_vidg_b4_yng_br** e **ea_read_b4_AAL_br** têm a maior correlação, ou seja, crianças que se envolvem em alguma atividade de leitura são fortemente correlacionadas com crianças que assitem vídeos ou jogam jogos educacionais no computador.

```{r}
matcorr_pre_3 <- cor(db_bloco_3_pre)
corrplot(matcorr_pre_3, method="circle", type = 'upper')
```
<br />

#### Bloco Pós Pandemia

Pode-se observar que a menor correlação continua sendo entre as variáveis **ea_read_b4_AAL_br** e **ea_edapp_b4_yng_br**, enquanto que a maior correlação passar a ser entre as variáveis **ea_tv_since_yng_br** e **ea_vidg_since_yng_br**, ou seja, entre crianças que assistem a vídeos/programas educacionais com computador e na TV.
```{r}
matcorr_pos_3 <- cor(db_bloco_3_pos)
corrplot(matcorr_pos_3, method="circle", type = 'upper')
```


#############################################################################################
## Multiple Correspondence Analysis

#### **Pré Pandemia**

```{r}
db_bloco_3_pref <- as.data.frame(lapply(db_bloco_3_pre, as.factor))
```

```{r}
summary(db_bloco_3_pref)
```

Podemos observar nos gráficos abaixo a frequência absoluta respostas para cada categoria de cada pergunta.

```{r}
# Plot de gráficos de barras para a quantidade de respostas por categoria por variável 
par(mfrow=c(2, 4))
plot(db_bloco_3_pref[,1], 
     main=colnames(db_bloco_3_pref)[1],
     ylab = "Count",
     col="steelblue",
     las = 2)
plot(db_bloco_3_pref[,2], 
                  main=colnames(db_bloco_3_pref)[2],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_3_pref[,3], 
                  main=colnames(db_bloco_3_pref)[3],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_3_pref[,4], 
                  main=colnames(db_bloco_3_pref)[4],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_3_pref[,5], 
                  main=colnames(db_bloco_3_pref)[5],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_3_pref[,5], 
                  main=colnames(db_bloco_3_pref)[6],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_3_pref[,5], 
                  main=colnames(db_bloco_3_pref)[75],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
  
```



> Construindo o MCA

```{r}
res.mca_pref_3 <- MCA(db_bloco_3_pref, graph = FALSE)
```

> Visualização e interpretação

Representação gráfica da porcentagem explicada por cada dimensão
```{r}
fviz_screeplot(res.mca_pref_3, addlabels = TRUE, ylim = c(0, 10))
```

> Correlação entre variáveis e dimensões principais

Pode-se observar que para as duas principais dimensões, a maioria das variáveis têm um correlação alta, destoando as variáveis **ea_read_b4_AAL_br** e **ea_indr_b4_AAL_br**.

```{r}
fviz_mca_var(res.mca_pref_3, choice = "mca.cor", 
            repel = TRUE, # Avoid text overlapping (slow)
            ggtheme = theme_minimal())
```

Agora visualizaando apenas as categorias de variáveis, ou seja, qual opção o responsável assinalou no questionário, é possível um grupo de alternativas que são bem explicadas pelas principais dimensões e um grupo de alternativas que não são explicadas pelas principais dimensões.

```{r}
fviz_mca_var(res.mca_pref_3, 
             col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE, # Avoid text overlapping (slow)
             ggtheme = theme_minimal())
```


Se uma categoria de variável é bem representada por duas dimensões, a soma do cos2 é próxima de um. Para alguns dos itens de linha, são necessárias mais de 2 dimensões para representar perfeitamente os dados, o que indica que essas alternativas fazem parte daquele grupo de alternativas no campo inferior esquerdo do gráfico acima.

```{r}
fviz_cos2(res.mca_pref_3, choice = "var", axes = 1:2)
```

15 principais categorias de variáveis que contribuem para cada uma das principais dimensões:

```{r}
# Contributions of rows to dimension 1
fviz_contrib(res.mca_pref_3, choice = "var", axes = 1, top = 15)
# Contributions of rows to dimension 2
fviz_contrib(res.mca_pref_3, choice = "var", axes = 2, top = 15)
```

## POS-PANDEMIA

```{r}
db_bloco_3_posf <- as.data.frame(lapply(db_bloco_3_pos, as.factor))
```

```{r}
summary(db_bloco_3_posf)
```

Podemos observar nos gráficos abaixo a frequência absoluta respostas para cada categoria de cada pergunta.
```{r}
par(mfrow=c(2, 4))
plot(db_bloco_3_posf[,1], 
                 main=colnames(db_bloco_3_posf)[1],
                 ylab = "Count",
                 col="steelblue",
                 las = 2)
plot(db_bloco_3_posf[,2], 
                  main=colnames(db_bloco_3_posf)[2],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_3_posf[,3], 
                  main=colnames(db_bloco_3_posf)[3],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_3_posf[,4], 
                  main=colnames(db_bloco_3_posf)[4],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_3_posf[,5], 
                  main=colnames(db_bloco_3_posf)[5],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_3_posf[,5], 
                  main=colnames(db_bloco_3_posf)[6],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
plot(db_bloco_3_posf[,5], 
                  main=colnames(db_bloco_3_posf)[7],
                  ylab = "Count",
                  col="steelblue",
                  las = 2)
  
```

> Construindo o MCA

```{r}
res.mca_posf_3 <- MCA(db_bloco_3_posf, graph = FALSE)
```

Porcentagens de inércia explicadas por cada dimensão MCA

```{r}
fviz_screeplot(res.mca_posf_3, addlabels = TRUE, ylim = c(0, 10))
```

Pode-se observar que para as duas principais dimensões, a maioria das variáveis têm um correlação alta, destoando um pouco as variáveis **ea_read_since_yng_br** e **ea_indr_since_yng_br**.
```{r}
fviz_mca_var(res.mca_posf_3, choice = "mca.cor", 
            repel = TRUE, # Avoid text overlapping (slow)
            ggtheme = theme_minimal())
```

Se uma categoria de variável é bem representada por duas dimensões, a soma do cos2 é próxima de um. Para alguns dos itens de linha, são necessárias mais de 2 dimensões para representar perfeitamente os dados.

```{r}
fviz_mca_var(res.mca_posf_3, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE, # Avoid text overlapping
             ggtheme = theme_minimal())
```


```{r}
fviz_cos2(res.mca_posf_3, choice = "var", axes = 1:2)
```

15 principais categorias de variáveis que contribuem para cada uma das principais dimensões:
```{r}
# Contributions of rows to dimension 1
fviz_contrib(res.mca_posf_3, choice = "var", axes = 1, top = 15)
# Contributions of rows to dimension 2
fviz_contrib(res.mca_posf_3, choice = "var", axes = 2, top = 15)
```